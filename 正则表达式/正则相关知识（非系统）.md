#### 使用exec多次匹配

```javascript
let sreg = /a/g
let str = 'bacac'
let strs = 'bacac'
sreg.lastIndex = 0   //表示从头开始匹配
let match = sreg.exec(str)
console.log(match[0])  //a
console.log(match.index)  //1
match = sreg.exec(strs)
console.log(match[0])  //a
console.log(match.index) //3   这里明明是对不同的字符串（知识内容不同）进行匹配，竟然跟对同一个字符串匹配效果一样，如果把第二个match=改成let matchs = 的话，反而a 1 a 1 的输出；另外，如果不用字符串都直接写'bacac'的话，也是输出a 1 a 3，感觉有点奇怪，记录一下。
```

获得每个匹配的老方法：

```javascript
var regex = /t(e)(st(\d?))/g;
var string = 'test1test2test3';

var matches = [];
var match;
while (match = regex.exec(string)) {
  matches.push(match);
}

matches
// [
//   ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],
//   ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],
//   ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
// ]
```

新方法：

```javascript
const string = 'test1test2test3';
const regex = /t(e)(st(\d?))/g;

for (const match of string.matchAll(regex)) {
  console.log(match);
}
// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
```

